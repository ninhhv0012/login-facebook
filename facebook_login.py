import requests
import re
import time
import json
import base64
from bs4 import BeautifulSoup
from urllib.parse import urlencode, urlparse
from utils import get_cookies_string
import random

class FacebookLogin:
    def __init__(self):
        self.session = requests.Session()
        self.setup_session()
    
    def setup_session(self):
        """C·∫•u h√¨nh session v·ªõi h√†nh vi tr√¨nh duy·ªát th·ª±c t·∫ø"""
        # S·ª≠ d·ª•ng User-Agent gi·ªëng tr√¨nh duy·ªát th·∫≠t
        user_agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36 Edg/136.0.0.0',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36'
        ]
        
        self.session.headers.update({
            'User-Agent': random.choice(user_agents),
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept-Encoding': 'gzip, deflate, br',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1',
            'Sec-Fetch-Dest': 'document',
            'Sec-Fetch-Mode': 'navigate',
            'Sec-Fetch-Site': 'none',
            'Sec-Fetch-User': '?1',
            'Cache-Control': 'max-age=0',
            'sec-ch-ua': '"Not_A Brand";v="8", "Chromium";v="120", "Google Chrome";v="120"',
            'sec-ch-ua-mobile': '?0',
            'sec-ch-ua-platform': '"Windows"'
        })
    
    def simulate_real_browsing(self):
        """M√¥ ph·ªèng h√†nh vi duy·ªát web th·ª±c t·∫ø tr∆∞·ªõc khi ƒëƒÉng nh·∫≠p"""
        try:
            print("üåê ƒêang m√¥ ph·ªèng h√†nh vi duy·ªát web th·ª±c t·∫ø...")
            
            # B∆∞·ªõc 1: Truy c·∫≠p trang ch√≠nh tr∆∞·ªõc
            time.sleep(random.uniform(1, 3))
            main_response = self.session.get('https://www.facebook.com/', timeout=15)
            print(f"‚úÖ ƒê√£ t·∫£i trang ch√≠nh: {main_response.status_code}")
            
            # B∆∞·ªõc 2: M√¥ ph·ªèng ƒë·ªô tr·ªÖ v√† h√†nh ƒë·ªông ng·∫´u nhi√™n
            time.sleep(random.uniform(2, 4))
            
            # B∆∞·ªõc 3: T·∫£i trang ƒëƒÉng nh·∫≠p v·ªõi tr∆∞·ªùng Referer ph√π h·ª£p
            self.session.headers.update({
                'Referer': 'https://www.facebook.com/'
            })
            
            login_response = self.session.get('https://www.facebook.com/login/', timeout=15)
            print(f"‚úÖ ƒê√£ t·∫£i trang ƒëƒÉng nh·∫≠p: {login_response.status_code}")
            
            return login_response.text, 'https://www.facebook.com/login/'
            
        except Exception as e:
            print(f"‚ùå M√¥ ph·ªèng duy·ªát web th·∫•t b·∫°i: {str(e)}")
            # Fallback to direct login page access
            return self.get_login_page_direct()
    
    def get_login_page_direct(self):
        """Truy c·∫≠p tr·ª±c ti·∫øp trang ƒëƒÉng nh·∫≠p (d·ª± ph√≤ng)"""
        try:
            response = self.session.get('https://www.facebook.com/', timeout=15)
            return response.text, 'https://www.facebook.com/'
        except Exception as e:
            raise Exception(f"L·ªói khi load trang: {str(e)}")
    
    def extract_comprehensive_form_data(self, html_content):
        """Tr√≠ch xu·∫•t d·ªØ li·ªáu form m·ªôt c√°ch to√†n di·ªán v·ªõi nhi·ªÅu k·ªπ thu·∫≠t"""
        soup = BeautifulSoup(html_content, 'html.parser')
        form_data = {}
        
        print("üîç B·∫Øt ƒë·∫ßu tr√≠ch xu·∫•t d·ªØ li·ªáu form...")
        
        # Ph∆∞∆°ng ph√°p 1: T√¨m ch√≠nh x√°c form ƒëƒÉng nh·∫≠p
        login_forms = []
        
        # Th·ª≠ nhi·ªÅu b·ªô ch·ªçn kh√°c nhau
        selectors = [
            {'data-testid': 'royal_login_form'},
            {'id': 'login_form'},
            {'action': re.compile(r'login')},
        ]
        
        for selector in selectors:
            forms = soup.find_all('form', selector)
            if forms:
                login_forms.extend(forms)
                print(f"‚úÖ Found {len(forms)} form(s) with selector: {selector}")
        
        # N·∫øu kh√¥ng t√¨m th·∫•y form ƒëƒÉng nh·∫≠p c·ª• th·ªÉ, s·ª≠ d·ª•ng t·∫•t c·∫£ c√°c form
        if not login_forms:
            login_forms = soup.find_all('form')
            print(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y form ƒëƒÉng nh·∫≠p c·ª• th·ªÉ, s·ª≠ d·ª•ng {len(login_forms)} form(s) t·ªïng qu√°t")
        
        # Tr√≠ch xu·∫•t d·ªØ li·ªáu t·ª´ c√°c form ƒëƒÉng nh·∫≠p
        for i, form in enumerate(login_forms):
            # In th√¥ng tin v·ªÅ form hi·ªán t·∫°i ƒëang ƒë∆∞·ª£c x·ª≠ l√Ω
            print(f"üîç ƒêang tr√≠ch xu·∫•t t·ª´ form {i+1}:")
            for inp in form.find_all('input'):
                name = inp.get('name')
                value = inp.get('value', '')
                input_type = inp.get('type', 'text')
                
                if name:
                    # Ch·ªâ l·∫•y c√°c tr∆∞·ªùng c·∫ßn thi·∫øt
                    if name not in ['email', 'pass']:
                        form_data[name] = value
                        print(f"   üìù {name} = {value[:30]}... (type: {input_type})")
        
        # Ph∆∞∆°ng ph√°p 2: S·ª≠ d·ª•ng regex ƒë·ªÉ tr√≠ch xu·∫•t c√°c token quan tr·ªçng
        token_patterns = {
            'lsd': [
                r'name="lsd"\s+value="([^"]+)"',
                r'"LSD"[^}]*"token":"([^"]+)"',
                r'"lsd":"([^"]+)"',
                r'LSD[^,]*,\s*\[\],\s*\{\s*"token"\s*:\s*"([^"]+)"'
            ],
            'jazoest': [
                r'name="jazoest"\s+value="([^"]+)"',
                r'"jazoest":"([^"]+)"',
                r'jazoest[^"]*"([^"]+)"'
            ],
            'fb_dtsg': [
                r'name="fb_dtsg"\s+value="([^"]+)"',
                r'"DTSGInitialData"[^}]*"token":"([^"]+)"',
                r'"fb_dtsg":"([^"]+)"',
                r'DTSGInitialData[^}]*token[^"]*"([^"]+)"'
            ],
            'datr': [
                r'"_js_datr","([^"]+)"',
                r'datr[^"]*"([^"]+)"'
            ]
        }
        
        print("üîç ƒêang tr√≠ch xu·∫•t token b·∫±ng regex patterns:")
        for token_name, patterns in token_patterns.items():
            if token_name not in form_data:
                for pattern in patterns:
                    matches = re.findall(pattern, html_content, re.IGNORECASE | re.DOTALL)
                    if matches:
                        # L·∫•y gi√° tr·ªã ƒë·∫ßu ti√™n kh√¥ng r·ªóng
                        value = next((m for m in matches if m.strip()), None)
                        if value:
                            # Lo·∫°i b·ªè k√Ω t·ª± kh√¥ng c·∫ßn thi·∫øt
                            value = value.replace('\\', '').replace('&amp;', '&').strip()
                            form_data[token_name] = value
                            print(f"   ‚úÖ {token_name}: {value[:30]}...")
                            break
                
                if token_name not in form_data:
                    print(f"   ‚ùå {token_name}: NOT FOUND")
        
        # Ph∆∞∆°ng ph√°p 3: Tr√≠ch xu·∫•t c√°c tr∆∞·ªùng b·ªï sung t·ª´ HTML
        additional_fields = {
            'privacy_mutation_token': r'privacy_mutation_token=([^&"]+)',
            'next': r'name="next"\s+value="([^"]*)"',
            'login_source': r'name="login_source"\s+value="([^"]*)"',
            'shared_prefs_data': r'name="shared_prefs_data"\s+value="([^"]*)"'
        }
        
        print("üîç Tr√≠ch xu·∫•t c√°c tr∆∞·ªùng b·ªï sung:")
        for field_name, pattern in additional_fields.items():
            if field_name not in form_data:
                match = re.search(pattern, html_content, re.IGNORECASE)
                if match:
                    form_data[field_name] = match.group(1)
                    print(f"   ‚úÖ {field_name}: {match.group(1)[:30]}...")
        
        # Ph∆∞∆°ng ph√°p 4: Th√™m c√°c gi√° tr·ªã m·∫∑c ƒë·ªãnh n·∫øu kh√¥ng c√≥
        defaults = {
            'login_source': 'comet_headerless_login',
            'next': '',
            'shared_prefs_data': ''
        }
        
        for key, value in defaults.items():
            if key not in form_data:
                form_data[key] = value
                print(f"   üìù M·∫∑c ƒë·ªãnh {key}: {value}")
        
        print(f"‚úÖ T·ªïng s·ªë tr∆∞·ªùng ƒë√£ tr√≠ch xu·∫•t: {len(form_data)}")
        
        # X√°c th·ª±c c√°c tr∆∞·ªùng quan tr·ªçng
        critical_fields = ['lsd']  # T·ªëi thi·ªÉu ch√∫ng ta c·∫ßn lsd
        missing_critical = [field for field in critical_fields if field not in form_data]
        
        if missing_critical:
            print(f"‚ùå Thi·∫øu c√°c tr∆∞·ªùng quan tr·ªçng: {missing_critical}")
            return None
        
        return form_data
    
    def login(self, email, password, two_fa_code=None):
        """ƒêƒÉng nh·∫≠p Facebook n√¢ng cao v·ªõi kh·∫£ nƒÉng tr√°nh ph√°t hi·ªán bot t·ªët h∆°n"""
        try:
            print("üöÄ B·∫Øt ƒë·∫ßu qu√° tr√¨nh ƒëƒÉng nh·∫≠p Facebook...")
            
            # B∆∞·ªõc 1: M√¥ ph·ªèng duy·ªát web th·ª±c t·∫ø
            html_content, login_url = self.simulate_real_browsing()
            
            # B∆∞·ªõc 2: Tr√≠ch xu·∫•t d·ªØ li·ªáu form
            form_data = self.extract_comprehensive_form_data(html_content)
            
            if not form_data:
                return {
                    'success': False,
                    'message': 'Kh√¥ng th·ªÉ tr√≠ch xu·∫•t c√°c token ƒëƒÉng nh·∫≠p c·∫ßn thi·∫øt t·ª´ Facebook. C·∫•u tr√∫c trang c√≥ th·ªÉ ƒë√£ thay ƒë·ªïi.',
                    'cookies': None
                }
            
            # B∆∞·ªõc 3: Chu·∫©n b·ªã payload ƒëƒÉng nh·∫≠p th·ª±c t·∫ø
            login_payload = {
            'email': email,
            'pass': password,
            'login': 'Log In'  # ƒê√¢y l√† gi√° tr·ªã c·ªßa n√∫t
            }
            
            # Th√™m t·∫•t c·∫£ d·ªØ li·ªáu form ƒë√£ tr√≠ch xu·∫•t
            login_payload.update(form_data)
            
            print(f"üéØ Payload ƒëƒÉng nh·∫≠p cu·ªëi c√πng c√≥ {len(login_payload)} tr∆∞·ªùng")
            print(f"üìù C√°c key trong payload: {list(login_payload.keys())}")
            
            # B∆∞·ªõc 4: Thi·∫øt l·∫≠p headers th·ª±c t·∫ø cho POST
            self.session.headers.update({
                'Referer': 'https://www.facebook.com/',
                'Origin': 'https://www.facebook.com',
                'Content-Type': 'application/x-www-form-urlencoded',
                'Sec-Fetch-Dest': 'document',
                'Sec-Fetch-Mode': 'navigate',
                'Sec-Fetch-Site': 'same-origin',
                'Sec-Fetch-User': '?1'
            })
            
            # B∆∞·ªõc 5: Th√™m ƒë·ªô tr·ªÖ th·ª±c t·∫ø tr∆∞·ªõc khi ƒëƒÉng nh·∫≠p
            time.sleep(random.uniform(2, 5))
            
            # B∆∞·ªõc 6: Th·ª±c hi·ªán ƒëƒÉng nh·∫≠p v·ªõi endpoint ph√π h·ª£p
            login_endpoint = 'https://www.facebook.com/login/device-based/regular/login/'
            
            # Th√™m privacy mutation token v√†o URL n·∫øu c√≥
            if 'privacy_mutation_token' in form_data:
                login_endpoint += f'?privacy_mutation_token={form_data["privacy_mutation_token"]}&next'
            
            print(f"üîÑ ƒêang g·ª≠i y√™u c·∫ßu ƒëƒÉng nh·∫≠p t·ªõi: {login_endpoint}")
            
            response = self.session.post(
                login_endpoint,
                data=login_payload,
                allow_redirects=True,
                timeout=30
            )
            
            print(f"üì® Ph·∫£n h·ªìi ƒëƒÉng nh·∫≠p: {response.status_code}")
            print(f"üìç URL cu·ªëi c√πng: {response.url}")
            
            # B∆∞·ªõc 7: Ki·ªÉm tra k·∫øt qu·∫£
            return self.check_login_result(response, email, password, two_fa_code)
            
        except Exception as e:
            return {
                'success': False,
                'message': f'L·ªói ƒëƒÉng nh·∫≠p: {str(e)}',
                'cookies': None
            }
    
    def check_login_result(self, response, email, password, two_fa_code):
        """Ki·ªÉm tra k·∫øt qu·∫£ ƒëƒÉng nh·∫≠p n√¢ng cao"""
        response_text = response.text.lower()
        response_url = response.url.lower()
        
        print(f"üîç ƒêang ph√¢n t√≠ch ph·∫£n h·ªìi...")
        print(f"   Tr·∫°ng th√°i: {response.status_code}")
        print(f"   URL: {response_url}")
        print(f"   ƒê·ªô d√†i n·ªôi dung: {len(response.text)}")
        
        # L∆∞u ph·∫£n h·ªìi ƒë·∫ßy ƒë·ªß ƒë·ªÉ debug
        with open('login_response_debug.html', 'w', encoding='utf-8') as f:
            f.write(response.text)
        
        # L∆∞u th√¥ng tin ph·∫£n h·ªìi
        with open('login_debug_info.txt', 'w', encoding='utf-8') as f:
            f.write(f"URL ph·∫£n h·ªìi: {response.url}\n")
            f.write(f"Tr·∫°ng th√°i ph·∫£n h·ªìi: {response.status_code}\n")
            f.write(f"Headers ph·∫£n h·ªìi: {dict(response.headers)}\n")
            f.write(f"Cookies phi√™n: {[f'{c.name}={c.value}' for c in self.session.cookies]}\n")
        
        print("üíæ C√°c file debug ƒë√£ ƒë∆∞·ª£c l∆∞u: login_response_debug.html, login_debug_info.txt")
        
        # Ki·ªÉm tra cookies
        cookie_names = [cookie.name for cookie in self.session.cookies]
        print(f"üç™ Cookies nh·∫≠n ƒë∆∞·ª£c: {cookie_names}")
        
        has_c_user = any(cookie.name == 'c_user' for cookie in self.session.cookies)
        has_xs = any(cookie.name == 'xs' for cookie in self.session.cookies)
        
        # Ph√°t hi·ªán th√†nh c√¥ng n√¢ng cao
        success_indicators = {
            'cookies': has_c_user and has_xs,  # C√≥ cookies quan tr·ªçng c_user v√† xs
            'url': any(pattern in response_url for pattern in [  # URL chuy·ªÉn h∆∞·ªõng ƒë·∫øn trang ch√≠nh
            'facebook.com/home', 'facebook.com/?sk=h_chr', 'facebook.com/?ref=',
            'facebook.com/feed', 'facebook.com/?_rdr'
            ]),
            'content': any(indicator in response_text for indicator in [  # N·ªôi dung trang ch√≠nh Facebook
            'feed_jewel', 'home_jewel', 'timeline', 'logout_form', 
            '"user_id"', 'composer', 'news_feed'
            ])
        }
        
        print(f"‚úÖ Ch·ªâ b√°o th√†nh c√¥ng: {success_indicators}")
        
        # Ph√°t hi·ªán l·ªói n√¢ng cao
        error_patterns = [  # C√°c m·∫´u l·ªói ƒëƒÉng nh·∫≠p
            'wrong password', 'incorrect password', 'login_error', 'error_box',
            'the password that you', 'your password was incorrect',
            'please re-enter your password', 'invalid username or password'
        ]
           
        has_errors = any(error in response_text for error in error_patterns)
        print(f"‚ùå Ph√°t hi·ªán l·ªói: {has_errors}")
        
        # Ki·ªÉm tra th√¥ng b√°o l·ªói c·ª• th·ªÉ trong HTML
        soup = BeautifulSoup(response.text, 'html.parser')
        error_divs = soup.find_all(['div', 'span'], class_=re.compile(r'error|Error'))
        for error_div in error_divs:
            if error_div.get_text(strip=True):
                print(f"üö® T√¨m th·∫•y th√¥ng b√°o l·ªói: {error_div.get_text(strip=True)[:100]}")
        
        # Ph√°t hi·ªán y√™u c·∫ßu x√°c th·ª±c 2 y·∫øu t·ªë
        needs_2fa = any([
            'checkpoint' in response_url,  # URL checkpoint c·ªßa Facebook
            'two-factor' in response_text,  # N·ªôi dung v·ªÅ x√°c th·ª±c 2 y·∫øu t·ªë
            'approvals_code' in response_text,  # M√£ x√°c th·ª±c
            'security check' in response_text  # Ki·ªÉm tra b·∫£o m·∫≠t
        ])
        
        print(f"üîê Y√™u c·∫ßu x√°c th·ª±c 2 y·∫øu t·ªë: {needs_2fa}")
        
        # X·ª≠ l√Ω logic quy·∫øt ƒë·ªãnh ƒëƒÉng nh·∫≠p
        print("üîç B·∫Øt ƒë·∫ßu x·ª≠ l√Ω logic quy·∫øt ƒë·ªãnh ƒëƒÉng nh·∫≠p...")
        
        # Ki·ªÉm tra x√°c th·ª±c 2 y·∫øu t·ªë
        if needs_2fa:
            print("üîê T√†i kho·∫£n y√™u c·∫ßu x√°c th·ª±c 2 y·∫øu t·ªë")
            if two_fa_code:
                print(f"üîë ƒêang x·ª≠ l√Ω m√£ 2FA: {two_fa_code}")
                return self.handle_2fa(two_fa_code, response)
            else:
                print("‚ùå Kh√¥ng c√≥ m√£ 2FA ƒë∆∞·ª£c cung c·∫•p")
                return {
                    'success': False,
                    'message': 'T√†i kho·∫£n y√™u c·∫ßu x√°c th·ª±c 2 y·∫øu t·ªë. Vui l√≤ng cung c·∫•p m√£ 2FA.',
                    'cookies': None
                }       
        
        # Ki·ªÉm tra ƒëƒÉng nh·∫≠p th√†nh c√¥ng
        if any(success_indicators.values()):
            print("‚úÖ Ph√°t hi·ªán d·∫•u hi·ªáu ƒëƒÉng nh·∫≠p th√†nh c√¥ng")
            # Ki·ªÉm tra cookies quan tr·ªçng
            if has_c_user == False and has_xs == False:
                print("‚ùå Kh√¥ng th·ªÉ l·∫•y ƒë∆∞·ª£c cookies quan tr·ªçng (c_user v√† xs)")
                return {
                'success': False,
                'message': 'Kh√¥ng th·ªÉ ƒëƒÉng nh·∫≠p ƒë·ªÉ l·∫•y cookies',
                'cookies': None
                }
                
            print("üç™ ƒêang l·∫•y cookies t·ª´ phi√™n ƒëƒÉng nh·∫≠p...")
            cookies = get_cookies_string(self.session)
            print("üéâ ƒêƒÉng nh·∫≠p th√†nh c√¥ng!")
            return {
            'success': True,
            'message': 'ƒêƒÉng nh·∫≠p th√†nh c√¥ng!',
            'cookies': cookies
            }
        
        # Ki·ªÉm tra l·ªói ƒëƒÉng nh·∫≠p
        if has_errors:
            print("‚ùå Ph√°t hi·ªán l·ªói ƒëƒÉng nh·∫≠p trong ph·∫£n h·ªìi")
            return {
            'success': False,
            'message': 'Email ho·∫∑c m·∫≠t kh·∫©u kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i th√¥ng tin ƒëƒÉng nh·∫≠p.',
            'cookies': None
            }
        
        # Ki·ªÉm tra n·∫øu v·∫´n ·ªü trang ƒëƒÉng nh·∫≠p (b√°o hi·ªáu th·∫•t b·∫°i)
        if 'login' in response_url or 'login' in response_text:
            print("‚ö†Ô∏è V·∫´n ·ªü trang ƒëƒÉng nh·∫≠p - ƒëƒÉng nh·∫≠p th·∫•t b·∫°i")
            return {
            'success': False,
            'message': 'ƒêƒÉng nh·∫≠p th·∫•t b·∫°i. Vui l√≤ng ki·ªÉm tra file login_response_debug.html ƒë·ªÉ bi·∫øt chi ti·∫øt.',
            'cookies': None
            }
        
        # Tr∆∞·ªùng h·ª£p kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c tr·∫°ng th√°i
        print("‚ùì Kh√¥ng th·ªÉ x√°c ƒë·ªãnh tr·∫°ng th√°i ƒëƒÉng nh·∫≠p")
        return {
            'success': False,
            'message': f'Tr·∫°ng th√°i ƒëƒÉng nh·∫≠p kh√¥ng r√µ r√†ng. Ki·ªÉm tra c√°c file debug. URL cu·ªëi c√πng: {response.url}',
            'cookies': None
        }
    
    def handle_2fa(self, two_fa_code, login_response):
        """X·ª≠ l√Ω x√°c th·ª±c 2 y·∫øu t·ªë v·ªõi tr√≠ch xu·∫•t form n√¢ng cao"""
        try:
            print(f"üîê ƒêang x·ª≠ l√Ω x√°c th·ª±c 2FA v·ªõi m√£: {two_fa_code}")
            
            # L·∫•y n·ªôi dung HTML t·ª´ ph·∫£n h·ªìi ƒëƒÉng nh·∫≠p
            html_content = login_response.text
            soup = BeautifulSoup(html_content, 'html.parser')
            
            # Tr√≠ch xu·∫•t t·∫•t c·∫£ d·ªØ li·ªáu form t·ª´ trang 2FA
            form_data = {}
            print("üîç ƒêang tr√≠ch xu·∫•t d·ªØ li·ªáu form t·ª´ trang x√°c th·ª±c 2FA...")
            
            for form in soup.find_all('form'):
                for inp in form.find_all('input'):
                    name = inp.get('name')
                    if name:
                        value = inp.get('value', '')
                        form_data[name] = value
                        print(f"   üìù T√¨m th·∫•y tr∆∞·ªùng: {name} = {value[:30]}...")
            
            print(f"‚úÖ ƒê√£ tr√≠ch xu·∫•t {len(form_data)} tr∆∞·ªùng t·ª´ form 2FA")
            
            # Chu·∫©n b·ªã payload cho vi·ªác g·ª≠i m√£ 2FA
            twofa_payload = {
                'approvals_code': two_fa_code,  # M√£ x√°c th·ª±c 2FA
                'submit[Continue]': 'Continue',  # N√∫t ti·∫øp t·ª•c
                'save_device': '1'  # L∆∞u thi·∫øt b·ªã tin c·∫≠y
            }
            # Th√™m t·∫•t c·∫£ d·ªØ li·ªáu form ƒë√£ tr√≠ch xu·∫•t
            twofa_payload.update(form_data)
            
            print(f"üéØ Payload 2FA cu·ªëi c√πng c√≥ {len(twofa_payload)} tr∆∞·ªùng")
            print(f"üìù C√°c tr∆∞·ªùng ch√≠nh: {list(twofa_payload.keys())}")
            
            # G·ª≠i m√£ 2FA
            print("üîÑ ƒêang g·ª≠i m√£ x√°c th·ª±c 2FA...")
            twofa_response = self.session.post(
                login_response.url,  # S·ª≠ d·ª•ng URL t·ª´ ph·∫£n h·ªìi ƒëƒÉng nh·∫≠p
                data=twofa_payload,
                allow_redirects=True,
                timeout=20
            )
            
            print(f"üì® Ph·∫£n h·ªìi 2FA: {twofa_response.status_code}")
            print(f"üìç URL cu·ªëi c√πng sau 2FA: {twofa_response.url}")
            
            # Ki·ªÉm tra k·∫øt qu·∫£ sau khi x·ª≠ l√Ω 2FA
            return self.check_login_result(twofa_response, "", "", None)
            
        except Exception as e:
            print(f"‚ùå L·ªói x·ª≠ l√Ω 2FA: {str(e)}")
            return {
                'success': False,
                'message': f'X·ª≠ l√Ω x√°c th·ª±c 2FA th·∫•t b·∫°i: {str(e)}',
                'cookies': None
            }